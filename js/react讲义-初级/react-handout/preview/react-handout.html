<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:react-handout</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="react-">react 基础讲义</h1>
<h2 id="-">搭建环境</h2>
<p>基本步骤</p>
<ul>
<li>安装 <code>node</code>, 要求最新版本</li>
<li>使用 <code>npm</code> 安装 <code>react</code>, <code>react-dom</code>, <code>roadhog</code></li>
<li>使用 <code>roadhog</code> 启动开发</li>
</ul>
<blockquote>
<p>使用 <code>roadhog</code>, 不用安装其他转码等包( 都会自动安装 ), 非常容易上手</p>
<p>官方建议使用 <code>npx</code> 安装 <code>create-react-app</code> 项目进行上手</p>
</blockquote>
<p>操作详情</p>
<h3 id="-node-npm-">安装 node, 配置 npm 仓库</h3>
<pre><code class="lang-sh">$ npm config set registry=https://registry.npm.taobao.org
</code></pre>
<h3 id="-">初始化</h3>
<pre><code class="lang-sh"># 新建文件夹
$ mkdir react-test
$ cd react-test

# 初始化 npm, 下载包
$ npm init -y
$ npm i react react-dom roadhog

# 新建文件与文件夹
$ mkdir public src
$ touch public/index.html src/index.jsx
</code></pre>
<blockquote>
<p><code>src/index.js</code> 是默认文件</p>
</blockquote>
<h3 id="-">编辑配置文件</h3>
<p>编辑 <code>package.json</code>, 添加 <code>roadhog</code> 的调试命令.</p>
<pre><code class="lang-json">{
    &quot;script&quot;: {
        &quot;dev&quot;: &quot;roadhog dev&quot;,
        &quot;build&quot;: &quot;roadhog build&quot;
    }
}
</code></pre>
<h3 id="-index-html-">编辑 <code>index.html</code> 文件</h3>
<p>放在 <code>public</code> 目录下的所有文件会拷贝到运行目录下, 编辑该文件提供:</p>
<ul>
<li>react 组件容器</li>
<li>引入 index.js 文件</li>
</ul>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;

    &lt;script src=&quot;/index.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="-index-jsx-">编辑 <code>index.jsx</code> 文件</h3>
<p>直接使用 jsx 语法, <code>roadhog</code> 会自动转码, 生成 js 文件. 
同时, 在 dev 环境下会生成在虚拟的 / 目录下. 同时支持即时更新.</p>
<pre><code class="lang-jsx">import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

ReactDOM.render(
    &lt;div&gt;{&#39;Hello World&#39;}&lt;/div&gt;
    , document.querySelector( &#39;#root&#39; )
);
</code></pre>
<h3 id="-">启动开发</h3>
<p>使用命令</p>
<pre><code class="lang-sh">$ npm run dev
</code></pre>
<p>即可获得运行结果, 编辑代码实时更新.</p>
<pre><code class="lang-jsx">import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

ReactDOM.render(
    &lt;div style={{width: &#39;300px&#39;, height: &#39;100px&#39;, border: &#39;1px dashed red&#39;}}&gt;{&#39;Hello World&#39;}&lt;/div&gt;
    , document.querySelector( &#39;#root&#39; )
);
</code></pre>
<!------------------------------------------------------------------------->
<h2 id="jsx-">JSX 简介</h2>
<p>JSX 就是 JavaScript XML, 是符合 XML 规则的标签的语法糖.</p>
<blockquote>
<p>底层调用的 是 React.createElement 等方法</p>
</blockquote>
<h3 id="-jsx-js-">在 JSX 中使用 js 表达式</h3>
<ul>
<li>需要将 js 表达式放在 或括号中</li>
</ul>
<pre><code class="lang-jsx">ReactDOM.render(
    &lt;div&gt;
        &lt;div&gt;{ &#39;一段字符串&#39; }&lt;/div&gt;
        &lt;div&gt;{ 1 + 2 + 3 }&lt;/div&gt;
        &lt;div&gt;{ [ 1, 2, 3, 4 ].join( &#39;---&#39; ) }&lt;/div&gt; 
    &lt;/div&gt;,
    document.getElementById( &#39;root&#39; )
);
</code></pre>
<h3 id="jsx-">JSX 本身也是一种表达式</h3>
<p>可以将 JSX 语法的结果存储在变量中, 作为参数传递, 作为返回值等.</p>
<pre><code class="lang-jsx">function getGreeting(user) {
  if (user) {
    return &lt;h1&gt;Hello, {user}!&lt;/h1&gt;;
  }
  return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;
}

ReactDOM.render(
    &lt;div&gt;
        &lt;div&gt;{ &#39;JSX 也是一种表达式&#39; }&lt;/div&gt;
        &lt;div&gt;{ getGreeting() }&lt;/div&gt;
        &lt;div&gt;{ getGreeting( &#39;jk&#39; ) }&lt;/div&gt; 
    &lt;/div&gt;,
    document.getElementById( &#39;root&#39; )
);
</code></pre>
<h3 id="jsx-">JSX 属性</h3>
<ul>
<li>可以使用引号来定义为字符串的属性值</li>
<li>可以使用花括号来定义为对象的属性值</li>
</ul>
<blockquote>
<p>如果使用对象就不要使用引号了</p>
</blockquote>
<pre><code class="lang-jsx">const element = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;;
const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt;;
</code></pre>
<h3 id="jsx-">JSX 嵌套</h3>
<p>上面的代码一直在使用嵌套</p>
<blockquote>
<p>JSX 是 XML, 所以必须有结束标签</p>
<p>为了与 html 标签冲突, JSX 组件都使用 PascalCase</p>
<p>JSX 中的属性均使用 camelCase 命名规则</p>
<p>其中: <code>class</code> 变成 <code>className</code>, <code>tabindex</code> 变成 <code>tabIndex</code> 等.</p>
</blockquote>
<h3 id="jsx-">JSX 防注入攻击</h3>
<p>JSX 中的表达式会转换成字符串</p>
<pre><code class="lang-jsx">&lt;div&gt;{ [ 1, 2, 3 ].join( &#39;&lt;/div&gt;&lt;div&gt;&#39; ) }&lt;/div&gt;
</code></pre>
<p>不会得到 &quot;预期&quot; 结果.</p>
<h3 id="jsx-objects">JSX 代表 Objects</h3>
<p>Babel 转译器会把 JSX 转换成一个名为 <code>React.createElement()</code> 的方法调用</p>
<!------------------------------------------------------------------------->
<h2 id="-">元素渲染</h2>
<ul>
<li>元素是构成 React 应用的最小单位.</li>
<li>与 DOM 元素不同, React 的元素是普通对象</li>
<li>ReactDOM 确保两者一致</li>
<li>React 元素是不可变对象 ( * ), 如果需要修改, 可以重新生成.</li>
<li>React 只会更新不同 ( Diff 算法 )</li>
</ul>
<p>例如: </p>
<pre><code class="lang-jsx">// 计时器. 一个例子, 一般不会这么使用
function tick() {
  const element = (
    &lt;div&gt;
      &lt;h1&gt;Hello, world!&lt;/h1&gt;
      &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt;
    &lt;/div&gt;
  );
  ReactDOM.render(element, document.getElementById(&#39;root&#39;));
}

setInterval(tick, 1000);
</code></pre>
<!------------------------------------------------------------------------->
<h2 id="-props">组件与 Props</h2>
<ul>
<li>组件将 UI 分割成独立, 可复用的部件. </li>
<li>组件可以接收参数( props )</li>
</ul>
<h3 id="-">定义组件</h3>
<p>可以使用构造函数</p>
<pre><code class="lang-jsx">function Webcome( props ) {
    return &lt;div&gt;{ JSON.stringify( props ) }&lt;/div&gt;;
}
</code></pre>
<p>可以使用 类 语法</p>
<pre><code class="lang-jsx">class Welcome extends React.Component {
    render() {
        return &lt;div&gt;{ JSON.stringify( this.props ) }&lt;/div&gt;;
    }
}
</code></pre>
<blockquote>
<p>组件必须只有一个根标签.</p>
</blockquote>
<h3 id="-">组件渲染</h3>
<p>定义的组件就可以作为 JSX 标签使用</p>
<pre><code class="lang-jsx">import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

function Welcome1 ( props ) {
    return &lt;div&gt;{ JSON.stringify( props ) }&lt;/div&gt;;
}

class Welcome2 extends React.Component {
    render() {
        return &lt;div&gt;{ JSON.stringify( this.props ) }&lt;/div&gt;;
    }
}

class Welcome3 extends React.Component {
    constructor( props ) {
        super();
        console.log( arguments );
        console.log( this.props ); // 数据还没有传过来, 可以使用第一个构造函数参数
        console.log( props );  
    }
    render() {
        // console.log( this.props ); // 可以打印出对象
        return &lt;div&gt;{ JSON.stringify( this.props ) }&lt;/div&gt;;
    }
}

ReactDOM.render(
    &lt;div&gt;
        &lt;Welcome1 name=&quot;jim&quot; age=&quot;19&quot; gender=&quot;male&quot; list={[ 1, 2, 3 ]} /&gt;
        &lt;Welcome2 name=&quot;tom&quot; age=&quot;18&quot; gender=&quot;female&quot; /&gt;
        &lt;Welcome3 name=&quot;lily&quot; age=&quot;19&quot; gender=&quot;female&quot; list={[ 1, 2, 3 ]} /&gt;
    &lt;/div&gt;,
    document.getElementById( &#39;root&#39; )    
);
</code></pre>
<h3 id="-">组合组件</h3>
<ul>
<li>组件可以在它的输出中引用其它组件</li>
<li>可以用同一组件来抽象出任意层次的细节</li>
<li>在React应用中，按钮、表单、对话框、整个屏幕的内容等，这些通常都被表示为组件</li>
<li>通常一个 React 应用顶部有一个 App 组件</li>
<li>如果是现有项目使用 React, 可以自下而上封装组件</li>
</ul>
<h3 id="-">提取组件</h3>
<ul>
<li>当出现复杂嵌套时, 即可抽取创建新组件</li>
</ul>
<h3 id="props-">Props 的只读性</h3>
<ul>
<li>无论是使用类还是构造函数, 一定不要修改其 props.</li>
<li>规则: React 组件必须像纯函数那样使用 props.</li>
</ul>
<!------------------------------------------------------------------------->
<h2 id="state-">State 与 生命周期</h2>
<p>生命周期图解:</p>
<p><img src="./assets/LifeCycle.png" alt=""></p>
<h3 id="-">有状态组件</h3>
<ul>
<li>状态与属性类似</li>
<li>只有类语法的组件才具有状态</li>
</ul>
<p>在构造函数中创建 <code>this.state</code></p>
<blockquote>
<p>如果没有视觉上需要的数据, 可以定义成其他字段</p>
</blockquote>
<p>更新 <code>state</code> 的数据. 使用 setState 方法 ( 异步的 )</p>
<pre><code class="lang-jsx">this.setState( {
    需要修改的字段: 修改后的值
} );
// 或
this.setState( function ( preValue, value ) {
    return {
        ...
    }
} );
// 
</code></pre>
<blockquote>
<p>注意: 不要直接修改 this.state 的值( 成员 )</p>
</blockquote>
<h3 id="-">组件的生命周期钩子( 看图 )</h3>
<pre><code class="lang-js">// 1. 静态属性 static defaultProps, static propTypes
// 2. 构造函数调用
// 3. 构造函数中初始化 this.state
// 4. 生命周期函数钩子: componentWillMount()
// 5. 生命周期函数钩子: render()
// 6. 生命周期函数钩子: componentDidMount()
// 7. 进入状态循环
//  7.1 state 改变( 异步的 setState 方法 ), 调用生命周期钩子: shouldComponentUpdate()
//  7.2 true 则依次调用生命周期钩子: 
//      7.2.1 componentWillUpdate()
//      7.2.2 render()
//      7.2.3 componentDidUpdate()
//      7.2.4 回到状态循环
//  7.3 父组件修改 props, 出发生命周期钩子调用
//      7.3.1 componentWillReceiveProps()
//      7.3.2 shouldComponentUpdate()
//      ... componentWillUpdate()
//      ... render()
//      ... componentDidUpdate()
//      ...
// 8. 组件卸载, 调用 componentWillUnmount()
</code></pre>
<h3 id="-">数据自顶向下流</h3>
<blockquote>
<p>单向数据流</p>
</blockquote>
<!------------------------------------------------------------------------->
<h2 id="-">事件处理</h2>
<ul>
<li>React 的事件绑定属性名使用 camelCase</li>
<li>采用 JSX 语法需要传入一个函数作为事件处理函数, 而非 字符串</li>
<li>阻止事件的默认行为必须使用 <code>e.preventDefault()</code>. ( e 是一个合成事件 ) ( 需要代码示例 )</li>
<li>class 语法中 事件 处理函数是一个方法</li>
<li><code>this</code> 是一个问题. 可以使用箭头函数来解决 ( 需要代码示例 )</li>
</ul>
<p>例如:</p>
<pre><code class="lang-jsx">&lt;button onClick={click_handler}&gt; click &lt;/button&gt;
</code></pre>
<h3 id="-">传递参数</h3>
<blockquote>
<p>需要案例 </p>
</blockquote>
<p>可以使用箭头函数或 <code>bind</code> 的语法. 例如:</p>
<pre><code class="lang-jsx">&lt;button onClick={ ( e ) =&gt; this.deleteRow( id, e ) }&gt;Delete Row&lt;/button&gt;
&lt;button onClick={ this.deleteRow.bind( this, id ) }&gt;Delete Row&lt;/button&gt;
</code></pre>
<blockquote>
<p>注意, 事件处理函数的参数顺序需要根据调用来定义</p>
</blockquote>
<!------------------------------------------------------------------------->
<h2 id="-">条件渲染</h2>
<p>使用 js 的语法来实现条件渲染。</p>
<ul>
<li>可以使用 <code>if</code> 等语法</li>
<li>可以使用元素变量. 将需要渲染的存储在变量中生成</li>
<li>与运算符 <code>&amp;&amp;</code></li>
<li>三目运算符</li>
</ul>
<blockquote>
<p>阻止渲染, 只需要让 <code>render</code> 返回 <code>null</code> 即可</p>
</blockquote>
<!------------------------------------------------------------------------->
<h2 id="-key">列表与 Key</h2>
<ul>
<li>react 常使用 map 方法将数组生成为 JSX</li>
</ul>
<h3 id="-">渲染多个组件</h3>
<p>例如: </p>
<pre><code class="lang-jsx">ReactDOM.render(
    &lt;ul&gt;
        { list.map( v =&gt; &lt;li&gt;{ v }&lt;/li&gt; ) }
    &lt;/ul&gt;,
    document.getElementById( &#39;root&#39; )
);
</code></pre>
<h3 id="-">基础列表组件</h3>
<ul>
<li>可以将列表抽取成组件</li>
<li>列表为 <code>ListView</code> 组件 ( 接收数组参数进行初始化 )</li>
<li>列表项为 <code>ListViewItem</code> 组件</li>
</ul>
<blockquote>
<p>命名仅作示例参考 </p>
</blockquote>
<h3 id="keys">Keys</h3>
<p>作用是在 DOM 元素被 <em>新增</em> 或 <em>修改</em> 时, 帮助 React 识别.</p>
<ul>
<li>key 需要唯一, 一般使用索引 或 数据项的标示符 ( 例如: item.id )</li>
</ul>
<h4 id="-keys-">用 keys 提取组件</h4>
<ul>
<li>元素的 key 只有在它和它的兄弟节点对比时才有意义.</li>
</ul>
<blockquote>
<p>例如需要提取 <code>ListViewItem</code> 来表示 <code>li</code> 标签. key 应该放到 <code>ListViewItem</code> 中</p>
</blockquote>
<ul>
<li><p>key 仅作为 React 内部维护的标识, 不会渲染到页面中. 必要时应添加其他属性.</p>
</li>
<li><p>使用时如果 <code>map</code> 嵌套太多, 即可考虑提取组件.</p>
</li>
</ul>
<!------------------------------------------------------------------------->
<h2 id="-">表单</h2>
<h3 id="-">受控组件技术</h3>
<ul>
<li>React 元素中数据的更新依赖 <code>setState</code> 方法</li>
<li>而表单元素的数据由用户输入控制</li>
</ul>
<p>结合两者特征, 用户的输入交给 React 中的方法来处理( 事件形式 ),
表单的数据由状态属性 ( this.state 的成员 ) 来提供, 这就是 <code>受控组件</code>.</p>
<p>例如:</p>
<pre><code class="lang-jsx">class ControlComponent extends React.Component {

    constructor() {
        super();
        this.state = {
            value: &#39;&#39;
        };
    }

    click_handler( e ) {
        // console.log( this ); // 当前组件
        alert( this.state.value );
    }

    change_handler( e ) {
        // console.log( e ); // 每次输入会触发
        this.setState( {
            value: e.target.value
        } );
    }

    render () {
        // console.log( &#39;render&#39; ); // 每次输入会重新渲染
        return &lt;div&gt;
            &lt;input type=&quot;text&quot; 
                   onChange={ ( e ) =&gt; this.change_handler( e ) } 
                   value={ this.state.value } /&gt;
            &lt;button onClick={ ( e ) =&gt; this.click_handler( e ) } &gt; click &lt;/button&gt;
        &lt;/div&gt;;
    }

}
</code></pre>
<p>也可以使用 <code>ref</code> 属性添加元素引用到组件事例. 例如:</p>
<pre><code class="lang-jsx">class MyComponent extends React.Component {
    click_handler ( e ) {
        console.log( e );
        console.log( this ); // this 有一个 refs 属性, 是一个对象, 其 my_input 即 DOM 对象

        alert( this.refs.my_input.value );
    } 
    render() {
        console.log( &#39;render&#39; );
        return &lt;div&gt;
            &lt;input type=&quot;text&quot; ref=&quot;my_input&quot;/&gt;
            &lt;button onClick={ e =&gt; this.click_handler( e ) }&gt; my click &lt;/button&gt;
        &lt;/div&gt;
    }
}
</code></pre>
<h3 id="textarea-">textarea 标签</h3>
<p>其用法与单行文本框的用法一样</p>
<h3 id="select-">select 标签</h3>
<p>事例片段:</p>
<pre><code class="lang-jsx">&lt;form onSubmit={this.handleSubmit}&gt;
    &lt;label&gt;
        Pick your favorite La Croix flavor:
        &lt;select value={this.state.value} onChange={this.handleChange}&gt;
        &lt;option value=&quot;grapefruit&quot;&gt;Grapefruit&lt;/option&gt;
        &lt;option value=&quot;lime&quot;&gt;Lime&lt;/option&gt;
        &lt;option value=&quot;coconut&quot;&gt;Coconut&lt;/option&gt;
        &lt;option value=&quot;mango&quot;&gt;Mango&lt;/option&gt;
        &lt;/select&gt;
    &lt;/label&gt;
    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;
&lt;/form&gt;
</code></pre>
<h3 id="file-input-">file input 标签</h3>
<p>该标签的 <code>value</code> 值是只读的. 属于非受控组件.</p>
<h3 id="-">多个输入的解决方法</h3>
<p>多个 <code>input</code> 可以绑定一个事件处理函数. 在事件处理函数中使用元素的 <code>name</code> 属性.</p>
<pre><code class="lang-jsx">handleInputChange(event) {
    const target = event.target;
    const value = target.type === &#39;checkbox&#39; ? target.checked : target.value;
    const name = target.name;

    this.setState( {
        [name]: value
    } );
    // [name] 逻辑等价于:
    // var o = {}; o[ name ] = value;
}
</code></pre>
<blockquote>
<p>不一定是 <code>name</code>, 可以是其他属性</p>
</blockquote>
<h3 id="-">受控组件的替代方案</h3>
<ul>
<li>受控组件需要处理很多属性值绑定与方法, 会比较麻烦</li>
<li>可以使用非受控组件的处理办法: 使用 <code>ref</code></li>
</ul>
<!------------------------------------------------------------------------->
<h2 id="-">状态提升</h2>
<p>将子组件使用的数据存储到最近的公共父组件中. 
利用父子组件通信的形式进行数据同步. 
这就是 <code>状态提升</code></p>
<!-- 例子要走一遍 -->
<!-- 

3. 组件传值
  1) 父组件将数据传递给子组件
  2) 子组件将数据传递给父组件
  3) 兄弟组件之前的通信

3.1 什么是父子组件
  例如:
    <div> <!-- 作为容器, 就相当于是 父组件 ->
      <p>一段</p> <!-- 容器内的组件, 就是子组件 ->
    </div>
  评论列表案例

3.2 往组件中传入数据
  -> 传入数据的方法有两种
    1) 键值对一个个作为属性提供给组件
    2) 使用对象扩展运算符
  -> 使用参数的方法也有两种
    1) 在构造函数中使用, 需要使用构造函数的第一个参数
    2) 在其他函数中使用, 可以直接使用 this.props


3.3 子组件将数据传递给 父组件
  我们将数据传递给 父组件, 父组件是需要使用
  在 react 中, 子组件 将 数据传递给 父组件, 使用了类似于回调技巧

  例如: 数组的遍历
    arr.forEach( func )

  创建一个父组件, 用于显示一段文字
  创建子组件, 用于输入一段文字, 并提供一个按钮


 -->
<!------------------------------------------------------------------------->
<h2 id="-vs-">组合 vs 继承</h2>
<ul>
<li>建议使用组合而非继承</li>
<li>容器类组件可以使用预定义属性存放 JSX, 然后在渲染的时候显示出来 ( 出代码 )</li>
</ul>
<!------------------------------------------------------------------------->
<h2 id="react-">React 理念</h2>
<p>一般处理流程</p>
<ul>
<li>把 UI 划分出组件层级</li>
<li>用 React 创建出一个静态版本</li>
<li>定义 UI 状态的最小 ( 但是完整 ) 表示</li>
<li>确定你的 State 应该在哪里</li>
<li>添加反向数据流</li>
</ul>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>